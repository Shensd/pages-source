import React from 'react'
import { Link } from 'gatsby'

import Layout from '../components/layout/layout'

const exploit_example = () => (
	<Layout>
		<div>
			<h1>Exploitation Walkthrough</h1>
			<p>
				A walkthrough example of the steps to writing a simple exploit.
			</p>
			<h2>C Programming</h2>
			<div>
				<p>
					The C programming language is 
					the <a href="https://www.fullstackacademy.com/blog/nine-best-programming-languages-to-learn-2018"> most 
					popular language for systems programming</a>, created by Dennis Ritchie. Most other languages have
					adopted the syntax, and so the code is not hard to learn when switching from 
					other <a href="https://en.wikipedia.org/wiki/Strong_and_weak_typing">strongly typed</a> programming languages.
				</p>
				<p>
					While other languages are more widely used, such as Javascript, C#/Java or Python, these languages and 
					the technology that drives them are written in C or C++. The reason that C is so widely used and so important
					is the fact that it is a low level programming language, that is, it compiles to machine level assembly code. 
					Machine code is written according to the processor's specification. Due to the fact that nearly all modern PCs
					are Intel machines, the archictecture we will be looking at is x86 or x86_64 (the 64-bit equivalent of x86). 
				</p>
				<div>
					<h4>Here are some popular processor archictectures:</h4>
					<table>
						<tr>
							<th>Architecture</th>
							<th>Seen In</th>
							<th>Instruction Set</th>
						</tr>
						<tr>
							<td>x86</td>
							<td>Consumer PCs</td>
							<td><a href="https://en.wikipedia.org/wiki/X86_instruction_listings">
							https://en.wikipedia.org/wiki/X86_instruction_listings</a></td>
						</tr>
						<tr>
							<td>PIC</td>
							<td>Embedded Devices</td>
							<td>https://ez.com/</td>
						</tr>
					</table>
				</div>
				<p>
					<b>Assembly language</b> is similar to <b>machine language</b>, but there is a key
					difference. Assembly language is the human-friendly equivalent of machine code.
					While assembly programming may seem tedious at times, it is leaps and bounds easier
					to write in than machine language. 
				</p>
				<p>
					For example, to program <code>add 0x1 0x1</code> in assembly as machine code you
					can use the <code>add</code> opcode, found in the instruction set specs, <code>0x00</code>.
					So if the bytes <code>0x00 0x01 0x01</code> are placed into the instruction register
					and dispatched, the processor will use its ALU to add 1 + 1, without storing it anywhere.
					This is not so bad, but if it is required to translate every instruction in a more
					sophisicated program, to the respective opcodes, writing a program will take forever.
				</p>
				<p>
					A simple computer program known as an <b>assembler</b> will convert assembly code
					into machine code for us. Essentially, it reads the assembly language instructions 
					and looks up the respective opcode for us. Assembly language is 1 to 1 with machine code,
					each instruction in assembly results in a machine instruction. This can make coding tedious.
					This raises an interesting question: Can we write a program to make coding even easier?
					The answer is yes. 
				</p>
				<p>
					In the same way that tranlating of instructions to opcodes was tedious, writing the 
					same code structures would often get tedious. Consider the following code:
				</p>
				<div>
					<pre>
					0xF7FC XOR	EAX, EAX<br/>
					0xF800 CMP	EAX, 0x5<br/>
					0xF804 JE		0xF810<br/>
					0xF808 ADD	EAX, 0x1<br/>
					0xF80C JMP	0xF800<br/>
					0xF810 RET
					</pre>
				</div>
				<p>
					This is the assembly equivalent of <code>for(int i=0; i&lt;5; i++);</code>. Which
					one is easier to write? also, which one is easier to read? Modify?
					Thus, the C language was developed to <b>compile</b> higher level code
					into instructions that could then be assembled. Higher level is relative
					in this case, as C is still a low level language compared to most other
					popular languages. 
				</p>
				<p>
					While assemblers convert assembly to machine language directly, compilers do not.
					They have to make guesses and add inefficiency for the sake of reliability. For this
					reason, assembly is still used for lower level tasks that require efficiency, accuracy,
					or speed. One other benefit to assembly is that it is always delivered with a 
					software package because it <b>is</b> the software. Being able to read assembly gives a
					hacker the advantage; the source code is not needed to exploit a program. The assembly code
					can also sometimes be <b>decompiled</b> to essentially guess the source code.
				</p>
			</div>
			<h2>Exploiting A Program</h2>
			<div>
				<p>
					Consider the following program:
				</p>
				<iframe>
					
				</iframe>
			</div>
			<h2>Learning More</h2>
			<div>
				<p>
					The example in this walkthrough was borrowed from the 
					book <i>Hacking: The Art of Exploitation</i> by <i>Jon Erickson</i> and credit goes to the author.
					There are many excellent examples in this book, and I highly recommend reading it for
					anyone who is serious about learning to write their own exploits.
				</p>
			</div>
		</div>
	</Layout>
)

export default exploit_example
